### 反转链表-非递归版本和递归版本

反转链表实现点

- 入参指针判空
- 链表反转，要把当前节点next指针指向前驱节点，而单链表在遍历过程中，无法往前遍历，因此需要记录前驱节点
- 反转过程中，当前节点反转后，无法往后遍历，因此反转前，要记录当前节点的下一个节点，方便下一个节点的的反转



代码实现

```c
#include <iostream>
typedef struct _ListNode
{
    _ListNode* pNext;
    int value;
    _ListNode(int outvalue)
    {
        pNext = nullptr;
        value = outvalue;
    }
}ListNode;

//4 -> 8 -> 1 -> 9
class Solution
{
public:
    ListNode* ReverseList(ListNode* pHead)
    {
        if (pHead == nullptr || pHead->pNext == nullptr)
            return pHead;
        ListNode* pCurNode = pHead;
        ListNode* pPreNode = nullptr;//缓存前置节点，因为单链表在遍历过程中，无法知道前驱节点（头节点的前驱的节点为空）
        while (pCurNode)
        {
            ListNode* pTmpNode = pCurNode->pNext;//缓存下个当前节点，因为单链表反转后，无法定位到当前节点的下一个节点
            pCurNode->pNext = pPreNode;
            pPreNode = pCurNode;
            pCurNode = pTmpNode;
        }
        return pPreNode;
    };
    
    ListNode* ReverseListRecursion(ListNode* pHead)
    {
        if (pHead == NULL || pHead->pNext == NULL)               //链表为空直接返回，而pHead->pNext为空是递归基
            return pHead;
        ListNode* newHead = ReverseListRecursion(pHead->pNext);  //一直循环到链尾
        pHead->pNext->pNext = pHead;                             //翻转链表的指向
        pHead->pNext = NULL;                                     //记得赋值NULL，防止链表错乱
        return newHead;                                          //新链表头永远指向的是原链表的链尾
    }
};

int main()
{
    ListNode* pHead = new ListNode(4);
    pHead->pNext = new ListNode(8);
    pHead->pNext->pNext = new ListNode(1);
    pHead->pNext->pNext->pNext = new ListNode(9);
    pHead->pNext->pNext->pNext->pNext = nullptr;
    Solution so;
    ListNode* pNewHead = so.ReverseList(pHead);
    while (pNewHead) {
        std::cout << pNewHead->value << "->";
        pNewHead = pNewHead->pNext;
    }
    std::cout << std::endl;
    
    ListNode* pHead2 = new ListNode(4);
    pHead2->pNext = nullptr;
    ListNode* pNewHead2 = so.ReverseList(pHead2);
    while (pNewHead2) {
        std::cout << pNewHead2->value << std::endl;
        pNewHead2 = pNewHead2->pNext;
    }
    
    ListNode* pNewHead3 = so.ReverseList(nullptr);
    if (pNewHead3 == nullptr)
    {
        std::cout << "pNewHead3 is null" << std::endl;
    }
    
    //递归版本
    {
        ListNode* pHead = new ListNode(4);
        pHead->pNext = new ListNode(8);
        pHead->pNext->pNext = new ListNode(1);
        pHead->pNext->pNext->pNext = new ListNode(9);
        pHead->pNext->pNext->pNext->pNext = nullptr;
        Solution so;
        ListNode* pNewHead = so.ReverseListRecursion(pHead);
        std::cout << "Recursion : ";
        while (pNewHead) {
            std::cout << pNewHead->value << "->";
            pNewHead = pNewHead->pNext;
        }
        std::cout << std::endl;
    }
}
```

