TX最爱考的笔试题之一，sizeof求出某个结构体的大小，该题可以考察应聘者对各种变量类型大小的敏感性、对指针类型大小和数组类型大小的区别、结构体的内存对齐，虽然简单，但是考察面还是比较广泛的，对于应聘者的c语言功底有一定的要求。

### sizeof基本原理

定义：C语言提供了一个编译时(compile-time)一元运算符sizeof，它可以用来计算任一对象的长度。表达式sizeof(对象名)、sizeof(类型名)将返回一个整型值，它等于指定对象或类型占用的存储空间字节数。

从上面的定义可以看出，sizeof实际上是一个宏定义，在预编译期间sizeof操作符就被替换了，具体宏定义的格式如下所示：

```c++
#define _sizeof(T) ((size_t)(T*)) + 1))//适用于非数组的宏替换
#define array_sizeof(T) ((size_t)(&T+1)-(size_t)(&T))//适用于数组
```

对于非数组的宏定义，先是将0转换为T*类型的指针所指向的地址（此时地址为0）。然后对T类型的地址加1，相当于加上了T类型的大小（即得到了非数组T的大小）。前面的size_t只是将地址转化为int型的整数返回。

对于数组的宏定义，这里可以把数组T看成一个用户自定义的类型，&T表示数组类型的指针，对于数组类型指针加1相当于在地址上加上了该数组大小。由于是用户自定义的类型所以不能强制将0转化为数组类型的地址，只能用加1后的地址减去之前的地址，得到的差值就是数组本身所占的字节大小。

此外，C99以后支持了动态数组，所以对于这种类型使用sizeof是运行时确定的。


### sizeof求结构体大小

首先看一个简单的例子，结构体A的大小为16字节：

```c++
#include<iostream>
using namespace std;
struct A{
    int a;
    char b[5];
    short c;
    int d;
};
struct B{
    char a;
    int b;
    short c;
};
struct C{
    short a;
    char b;
    int c;
};
struct D{
    short* a;
    char b[3];
    double c;
};
int main(){
    cout << sizeof(A) << endl;//输出16
    cout << sizeof(B) << endl;//输出12
    cout << sizeof(C) << endl;//输出8
    cout << sizeof(D) << endl;//输出24
    return 0;
}
```

为了确定16字节的由来，我们队sizeof的计算分两步走，首先是确定基本类型大小，然后是内存对齐的规则。

#### 确定各个类型的大小

对于64位操作系统来说，各个类型所占的字节数为：

```c++
sizeof(char)=1
sizeof(short)=2
sizeof(int)=4
sizeof(long)=8
sizeof(long long)=8
sizeof(float)=4
sizeof(double)=8
sizeof(void*)=8
```

需要注意的是：32位系统的指针类型和long类型只占4字节。

#### 结构体内存对齐规则

有了各个类型的大小，接下来我们看看结构体内存对齐的规则，内存对齐具体缘由，这里不细说了，主要是出于性能和平台移植等因素的考虑。内存对齐的规则主要如下：

* 1.结构体变量的首地址能够被其最宽基本类型成员的大小所整除。（系统给结构体申请内存空间时，直接保证）
* 2.结构体每个成员相对于结构体首地址的偏移量是成员本身的整数倍，如果有需要编译器会在成员之间加上填充字节。
* 3.结构体的总大小为结构体最宽基本类型成员大小的整数倍，如果有需要编译器会在最末成员加上填充字节。（对于数组类型，只取数组每个元素类型的大小，而不是数组总长度）

注：这里所有的对齐细节与编译器相关，是因为每一个编译器有默认的对齐字节数。

因此，我们要计算某个结构体占用的内存空间，直接考虑2，3条即可。

针对开篇提出的例子，我们应用规则2，3，能很快得出结构体A的大小为16字节。

* 第一个变量a，占4字节，偏移量为4字节，因此偏移量是a大小的整数倍；

* 第二个变量b，总共占5字节，每个元素占1字节，偏移量为9字节，偏移量是每个元素大小的整数倍；

* 第三个变量c，占2字节，偏移量为11字节，偏移量不是c大小的整数倍，因此需要在变量b的末尾增加1字节，使得c的偏移量变为12字节；（应用规则2）
* 第四个变量d，占4字节，偏移量为12字节，偏移量是d大小的整数倍；
* 至此，结构体总大小16字节，为最宽基本类型a大小的整数倍，因此不需要再最末端补齐（不需要应用规则3）

按照同样的规则，我们可以得出其他结构体的大小。

### 参考

https://blog.csdn.net/xiaohanluo/article/details/39963747

https://levphy.github.io/2017/03/23/memory-alignment.html

https://www.zhihu.com/question/27862634
