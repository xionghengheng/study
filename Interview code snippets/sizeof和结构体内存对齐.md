TX最爱考的笔试题之一，sizeof求出某个结构体的大小，该题可以考察应聘者对各种变量类型大小的敏感性、对指针类型大小和数组类型大小的区别、结构体的内存对齐，虽然简单，但是考察面还是比较广泛的，对于应聘者的c语言功底有一定的要求。


### sizeof基本原理


### sizeof求结构体大小

首先看一个简单的例子，结构体A的大小为16字节：

```c++
#include<iostream>
using namespace std;
struct A{
    int a;
    char b[5];
    short c;
    int d;
};
struct B{
    char a;
    int b;
    short c;
};
struct C{
    short a;
    char b;
    int c;
};
struct D{
    short* a;
    char b[3];
    double c;
};
int main(){
    cout << sizeof(A) << endl;//输出16
    cout << sizeof(B) << endl;//输出12
    cout << sizeof(C) << endl;//输出8
    cout << sizeof(D) << endl;//输出24
    return 0;
}
```

为了确定16字节的由来，我们队sizeof的计算分两步走，首先是确定基本类型大小，然后是内存对齐的规则。

#### 确定各个类型的大小

对于64位操作系统来说，各个类型所占的字节数为：

```c++
sizeof(char)=1
sizeof(short)=2
sizeof(int)=4
sizeof(long)=8
sizeof(long long)=8
sizeof(float)=4
sizeof(double)=8
sizeof(void*)=8
```

需要注意的是：32位系统的指针类型和long类型只占4字节。

#### 结构体内存对齐规则

有了各个类型的大小，接下来我们看看结构体内存对齐的规则，内存对齐具体缘由，这里不细说了，主要是出于性能和平台移植等因素的考虑。内存对齐的规则主要如下：

* 1.结构体变量的首地址能够被其最宽基本类型成员的大小所整除。（系统给结构体申请内存空间时，直接保证）
* 2.结构体每个成员相对于结构体首地址的偏移量是成员本身的整数倍，如果有需要编译器会在成员之间加上填充字节。
* 3.结构体的总大小为结构体最宽基本类型成员大小的整数倍，如果有需要编译器会在最末成员加上填充字节。（对于数组类型，只取数组每个元素类型的大小，而不是数组总长度）

注：这里所有的对齐细节与编译器相关，是因为每一个编译器有默认的对齐字节数。

因此，我们要计算某个结构体占用的内存空间，直接考虑2，3条即可。

针对开篇提出的例子，我们应用规则2，3，能很快得出结构体A的大小为16字节。

* 第一个变量a，占4字节，偏移量为4字节，因此偏移量是a大小的整数倍；

* 第二个变量b，总共占5字节，每个元素占1字节，偏移量为9字节，偏移量是每个元素大小的整数倍；

* 第三个变量c，占2字节，偏移量为11字节，偏移量不是c大小的整数倍，因此需要在变量b的末尾增加1字节，使得c的偏移量变为12字节；（应用规则2）
* 第四个变量d，占4字节，偏移量为12字节，偏移量是d大小的整数倍；
* 至此，结构体总大小16字节，为最宽基本类型a大小的整数倍，因此不需要再最末端补齐（不需要应用规则3）

按照同样的规则，我们可以得出其他结构体的大小。

### 参考

https://blog.csdn.net/xiaohanluo/article/details/39963747

https://levphy.github.io/2017/03/23/memory-alignment.html

https://www.zhihu.com/question/27862634
